<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>CloudPlugin by dorugucea91</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">CloudPlugin</h1>
      <h2 class="project-tagline">Cloud Services Plugin for ImageJ - Gsoc 2015</h2>
      <a href="https://github.com/dorugucea91/CloudPlugin" class="btn">View on GitHub</a>
      <a href="https://github.com/dorugucea91/CloudPlugin/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/dorugucea91/CloudPlugin/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="developers" class="anchor" href="#developers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Developers</h1>

<p>Student: <a href="gucea.doru@gmail.com">Doru-Cristian Gucea</a><br>
Mentor1: <a href="dimiterpp@gmail.com">Dimiter Prodanov</a><br>
Mentor2: <a href="visakh@incf.org">Visakh Muraleedharan</a>   </p>

<h1>
<a id="organization" class="anchor" href="#organization" aria-hidden="true"><span class="octicon octicon-link"></span></a>Organization:</h1>

<p><a href="http://incf.org">International Neuroinformatics Coordinating Facility</a>   </p>

<h1>
<a id="project-description" class="anchor" href="#project-description" aria-hidden="true"><span class="octicon octicon-link"></span></a>Project description</h1>

<p>ImageJ is a public domain Java image processing program designed with an open architecture that provides extensibility via Java plugins. The aim of this project is to develop an ImageJ plugin which can be used to download/upload datasets from/to iRODS (Integrated Rule-Oriented Data System), an open source data management software used by the research community in order to take control of their data, regardless of where and on what device the data is stored</p>

<h3>
<a id="re-factoring" class="anchor" href="#re-factoring" aria-hidden="true"><span class="octicon octicon-link"></span></a>Re-factoring</h3>

<p>My project is forked from Atin's repository: <a href="https://github.com/Atin007/dbclient">https://github.com/Atin007/dbclient</a>, which is a GSoc 2014 project. Atin's project implements an ImageJ plugin for Dropbox, so I thought that it would be appropriate to integrate my new iRODS functionality as another cloud service.<br>
A lot of re-factoring was done to the old project in order to make it clear and easier to support for future developers. The problems with the coding style from the Gsoc 2014's project was that (quote from the project proposal belonging to Desmond, Joshua A.): </p>

<blockquote>
<p>The current project is nothing short of a mess, with a thorough lack of documentation, an
absence of automated JUnit tests, and a strong disregard for object oriented design principles. The
program admittedly works as it should, but from a software design perspective, it is unusable. In one
of the two classes within the entire program, for example, there is a method called “run” that is over
1000 lines long, (or, according to a SLOC counter, about 550 lines without comments). The method
“run” encapsulates building the GUI and its every component, defining all action listeners in their
entirety with anonymous class definitions, managing multiple threads, handling data validation from
Dropbox, making numerous calls to Swing, Dropbox, AWT, and ImageJ libraries, building and
representing the file tree from Dropbox, determining the operating system of the user, and probably
If anyone ever wants to build off or further develop MyCloudJ, refactoring is a must. No
further work could possibly get around that. </p></blockquote>

<p>Before starting to implement the functionality for iRODS, a lot of refactoring work was done. This work also continued while adding iRODS features. I will present the re-factoring challenges in this separate chapter, trying to isolate the presentation of the functionality from the presentation of the re-factoring. Stay tunned!</p>

<h3>
<a id="week-1" class="anchor" href="#week-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Week 1</h3>

<p><u>Deliverable 1:</u> Plugin with a simple GUI, asking for iRODS credentials. The plugin can create a session with the iRODS server and display a successful/not successful connection message.  </p>

<p>As can be observed from the below picture, I kept the GUI from Atin's project and modified just the login box, by providing the user with text inputs for entering the credentials. The user can switch between Dropbox and iRODS login using a Radio Button.</p>

<p>iRODS Login Screen<img src="images/screen_login_irods.png"></a></p>

<p>Code implementing the login part can be found in the login method from the rods_backend package. Every cloud plugin should implement a login method and that's the reason for making the login method an operation in the CloudOperations interface. </p>

<pre><code>
import org.irods.jargon.core.connection.IRODSAccount;
import org.irods.jargon.core.connection.IRODSProtocolManager;
import org.irods.jargon.core.connection.IRODSSession;
import org.irods.jargon.core.connection.IRODSSimpleProtocolManager;
import org.irods.jargon.core.exception.JargonException;
import org.irods.jargon.core.pub.IRODSAccessObjectFactory;
import org.irods.jargon.core.pub.IRODSAccessObjectFactoryImpl;
import org.irods.jargon.core.pub.io.IRODSFile;

public void login() throws CloudException {    
	String error;    
	IRODSProtocolManager connectionManager;   
	IRODSAccount account;   
	IRODSAccessObjectFactory accessObjectFactory;

	try {
		connectionManager = IRODSSimpleProtocolManager.instance();
		session = IRODSSession.instance(connectionManager);
		account = new IRODSAccount(host, port, user, password,
				homeDirectoryPath, zone, res);
		accessObjectFactory = IRODSAccessObjectFactoryImpl
				.instance(session);
		irodsFileFactory = accessObjectFactory.getIRODSFileFactory(account);

		buildHomePath();
		userIsLogged = true;
	} catch (JargonException e) {
		error = "Error login to iRODS";
		throw (new CloudException(error));
	}
}
</code></pre>

<p>As can be seen from the imports used,  the communication with the iRODS server was done using the <a href="https://github.com/DICE-UNC/jargon">Jargon API</a>, version 4.0.2.1. I created a jar (jargon-core-4.0.2.1-SNAPSHOT-jar-with-dependencies.jar) with the Jargon functionality and placed it in the libs folder then I linked my project against this jar.
A detailed explanation with all the fields used for the connection can be found <a href="https://github.com/DICE-UNC/jargon/wiki/Managing-connections">here</a>, but the field that we are intersted in is <i>irodsFileFactory</i>. This is the handler which will be used for reading/writing iRODS files from the cloud server. </p>

<p><u>iRODS server setup:</u> My changes were tested using a Virtual Box machine where I installed iRODS. The proposal of my mentors was to setup a public VM for easier testing. They provide me this machine and I installed iRODS on it. The problem is that I can't use the default listening port for iRODS (1247) because is not opened yet. Also, modifying the iRODS server to listen on port 80 (which is open) gave me an <a href="files/error_log">error</a>. We'll find a solution next week. </p>

<h3>
<a id="week-2" class="anchor" href="#week-2" aria-hidden="true"><span class="octicon octicon-link"></span></a>Week 2</h3>

<p><u>Deliverable 2:</u> Plugin wih the capability to browse the local file system and the remote iRODS file system.  </p>

<p>After a successful login to the iRODS server, input elements (RadioButton, JButton) from the right side of the main frame (iRODS Tasks) are activated:
<img src="images/active_right_frame.png"></p>

<p> The "Browse" buttons from the right side can be used for searching files either on the local file system or on the remote cloud file system, depending on the selected RadioButton (Upload/Download). First image illustrates the window for browsing files on the cloud filesystem while the second image shows the window for browsing files on the local file system: </p>

<p><img src="images/browse_cloud.png">&nbsp;&nbsp;&nbsp;<img src="images/browse_local.png"></p>


<p>UMLs describing the browsing functionality are displayed in the below figure. In order to separate the functionality between browsing trees, I created two distinct classes: 
<ul>
<li><p>CloudFileTree - implements methods for browsing the cloud file system. In order to make this class easy extendable to another cloud file system, the constructor of CloudFileTree receives as parameter a CloudOperations handler. In this way, CloudFileTree can be used to browse the file system for any cloud service which implements the CloudOperations interface, more specific, the listFiles method which creates a list with CloudFiles from a specific path. In my program, the CloudFileTree is used to browse the iRODS file system by implementing the back end communication with the iRODS server in the RodsOperations class but the CloudFileTree can be easy extended to browse the Dropbox filesystem if back end communication with Dropbox implements the CloudOperations class.<p>
<p>The basic principle from this class is very simple: every time the user clicks the Expand button, the selected node is expanded with a list of CloudFiles by calling the listFiles method. It's worth mentioning that the listFiles method is the only method used from the cloud handler.<p>

 </li>
<li>LocalFileTree - implements methods for browsing the local file system. This class is very simple because it uses the built-in ImageJ file browser. </li>
</ul>

MyCloudJ_ class just calls methods for drawing the file selection window and afterwards, it assigns ActionListeners for the JButtons inside these windows. Specific browsing processing is done inside those CloudFileTree and LocalFileTree.
  </p>
<p><img src="images/uml_browsing.png"></p>

<p><u>Server setup:</u> My mentors opened the port 1247 on the remote VM and I successfully tested my work. The main problem that I encountered was that the default resource specified at login didn't exist on the iRODS server and I got some errors while uploading files. Solved this problem by not specfing a default resource. The iRODS community helped me to solve the<a href="https://groups.google.com/forum/#!topic/irod-chat/dOIOrhMnbSw"> problem.</a></p>


<h3>
<a id="week-3" class="anchor" href="#week-3" aria-hidden="true"><span class="octicon octicon-link"></span></a>Week 3 and 4</h3>

<p><u>Deliverable 3:</u> Plugin with upload and download file functionality from iRODS</p>
A file transfer is initialized by following the next steps:
<p style="text-align:center"><img src="images/start_button.png"></p>
<li>one of the two radio buttons is selected: upload/download;</li>
<li>the source path of the file is choosen. Depending on the upload/download radio button selected the source can be from the local filesystem/cloud filesystem respectively;</li>
<li>the destination path of the file is chosen. Depending on the upload/download radio button selected the source can be from the cloud filesystem/local filesystem respectively;</li>
<li>upload/download process is started using the "Start" button.</li>
</ul>

<p>The action listener assigned to the start button starts a new thread for every upload/download operation(see also the UML diagram below): <p>

<pre><code>
class BtnStartListener implements ActionListener {
    @Override
    public void actionPerformed(ActionEvent e) {
    String sourcePath = tasksWindow.getSourcePath();
    String destinationPath = tasksWindow.getDestinationPath();

    if (sourcePath.equals("") || destinationPath.equals("")) {
        tasksWindow.getLogger().writeLog("Error: Select the files/folder to upload/download\n\n");
        return;
    }

    if (tasksWindow.getUploadRadioButton().isSelected()) {
        UploadThread uploadThread = new UploadThread(cloudHandler, cloudFileTree, tasksWindow.getLogger());
        uploadThread.prepareForUpload(sourcePath, destinationPath);
        uploadThread.start();
    } else if (tasksWindow.getDownloadRadioButton().isSelected()) {
        DownloadThread downloadThread = new DownloadThread(cloudHandler, tasksWindow.getLogger());
        downloadThread.prepareForDownload(sourcePath, destinationPath);
        downloadThread.start();
    }
}
</code></pre>

<h4>File Download</h4>
The DownloadThread class constructor receives as parameters two object:
<ul>
<li>a CloudOperations object: this is an object which implements the download backend with the iRODS server in the downloadFile method.</li>
<li>a Logger object which implements synchronized methods for logging. The result of the download thread will be written to this logger using the synchronized method writeLog. We needed to implement the writeLog as a synchronized method because there might be multiple threads trying to write logs at the same time. </li>
</ul>

The RodsOperations class implements the CloudOperations interface. The downloadFile method uses Jargon API methods for file transfer operations where the flow is pretty similar with the one from the standard Java IO. We first access the cloud file by creating an IRODSFile. Once we accessed the file, we get an input stream as a IRODSFileInputStream then we can read the bytes from the cloud file as a byte stream. We can write this byte stream to a local file using standard Java IO operations. It's worth mentioning that we can download any file type as long as we're working at a byte level:

<pre><code>
@Override
public void downloadFile(String cloudPath, String localPath)
                         throws CloudException {
    FileOutputStream fos = null;
    IRODSFileInputStream irodsFileInputStream = null;
    int bytesRead, chunkSize = 4096;
    String error = "";
    String fileName;

    checkPaths(localPath, cloudPath);

    // extract the name of the file from full path
    fileName = GeneralUtility.getLastComponentFromPath(cloudPath,
                RODS_DELIMITER);
    localPath += (GeneralUtility.getSystemSeparator() + fileName);

    try {
        // access the file on cloud
        IRODSFile irodsFile = irodsFileFactory.instanceIRODSFile(cloudPath);
        irodsFileInputStream = irodsFileFactory
                        .instanceIRODSFileInputStream(irodsFile);

         // access the file on the local filesystem
         fos = new FileOutputStream(localPath);

         // save the file as a byte stream
         byte[] saveAsFileByteStream = new byte[chunkSize];
         transferSize = irodsFile.length();
			
         while ((bytesRead = irodsFileInputStream.read(saveAsFileByteStream,
                       0, chunkSize)) != -1)
             fos.write(saveAsFileByteStream, 0, bytesRead);
    } catch (FileNotFoundException e) {
        e.printStackTrace();
        error = "File System Error: ";
        throw (new CloudException(error.concat(e.getMessage())));
    } catch (IOException e) {
        e.printStackTrace();
        error = "File System Error: ";
        throw (new CloudException(error.concat(e.getMessage())));
    } catch (JargonException e) {
        e.printStackTrace();
        error = "File was not found on iRODS server: ";
        throw (new CloudException(error.concat(e.getMessage())));
    } finally {
        try {
            if (fos != null)
                fos.close();
            if (irodsFileInputStream != null)
                irodsFileInputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
                error = "File System Error: ";
                throw (new CloudException(error.concat(e.getMessage())));
            }
    }
}
</code></pre>

<h4>File Upload</h4>
<p>
The UploadThread class constructor receives as parameters two object:
<ul>
<li>a CloudOperations object: this is an object which implements the download backend with the iRODS server in the uploadFile method;</li>
<li>a Logger object;</li>
<li>a CloudFileTree object. If the upload is successful we update the file browsing tree with the newly uploaded folder. This is done automatically without the user having to push the "Expand" button. This is done by calling the synchronized updateTrees method inside CloudFileTree class. This file browsing tree update is done only if the currently selected node path is included in the newly uploaded file path, otherwise we might confuse the user with information that he is not interested in at the moment. </li>
</ul>
The code for uploading is pretty similar with the one for download with the modification that we use an irodsFileOutputStream instead of an irodsFileInputStream.
</p>

<center>
<figure>
<img src="images/upload_download.png">
<figcaption>UML emphasizing the upload/download functionality</figcaption>
</figure>
</center>

<p><b>Problem:</b> Compared with iDrop, the upload/download speeds are much lower. I will investigate the problem in the coming weeks. <p>


<h3>
<a id="week-4" class="anchor" href="#week-4" aria-hidden="true"><span class="octicon octicon-link"></span></a>Week 4 and 5</h3>
<p><u>Deliverable 4:</u> Plugin with upload and download folder(trees) functionality from iRODS</p>
As I described in my last post, the upload/download speed were much lower than the ones obtained with iDrop. iRODS community <a href="https://groups.google.com/forum/#!topic/irod-chat/fFcxzPiAWMw">helped</a> me to solve this problem by advising to use a wrapper over file streams instead of using streams directly. For example, the the wrapper for a download file transfer is the getOperation:
<pre><code>
void getOperation(String irodsSourceFileAbsolutePath,
	String targetLocalFileAbsolutePath, String sourceResourceName,
	TransferStatusCallbackListener transferStatusCallbackListener,
	TransferControlBlock transferControlBlock)
throws FileNotFoundException, OverwriteException, JargonException;
</code></pre>
The getOperation uses a straight-forward read-ahead and write-behind cache that will act like the base jargon IO streams, but will only go to iRODS in 4MB or other sizes. This allowed me to obtain
a throughput improvement of ~5x. The get operation work both for file and folders.

<p>An interesting problem was the canceling of a file transfer in the middle of the transfer. This can happen is the user decides to disconnect from the cloud service and to close all the running 
file transfers. The getOperation receives the transferControlBlock callback as parameter which contains the API for canceling a file transfer. The problem is that this functionality is <a href="https://github.com/DICE-UNC/jargon/issues/90"> not yet implemented</a>, so I had to find an workaround. The solution came in the form of <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/FutureTask.html">FutureTask</a>, which is a cancellable asynchronous operation. What I had to do was to wrap my file transfer thread in a FutureTask and every time I want to cancel a running file transfer I just call the cancel method of FutureTask. The wrapping of file transfer objects inside a FutureTask object is possible only if that objects implements the Callable interface I had to implement the Callable interface inside. THe big advantage of using Callable for a thread is that the thread can return a result, which was impossible to do it directly using the classic Runnable interface. </p> 

<p>Regarding the patterns used, I kept the producer-consumer pattern, where the main thread produces tasks which are consumed by the file transfers thread: one thread for upload and one thread for download. I also used the Executor patter for submitting the FutureTask objects to execution. There are two Executors (one for download and one for upload), with a pool of one thread at the moment. In the Future I plan to use a single Executor with a pool of two threads: </p>

<p>
<center>
<figure>
<img src="images/upload_download_executor.png">
<figcaption>Simplified UML for file transfer operations</figcaption>
</figure>
</center>
</p>

<h3>
<a id="week-5" class="anchor" href="#week-5" aria-hidden="true"><span class="octicon octicon-link"></span></a>Week 5 and 6</h3>
<p><u>Deliverable 5:</u> Plugin with Dropbox functionality integration</p>
<p> The process of integrating the Dropbox functionality went smoothly because of the object oriented design until now. All I had to do was to group the Dropbox methods in a class which implements the CloudOperations interface: 
<ul>
<li>login</li>
<li>disconnect</li>
<li>downloadFile</li>
<li>downloadFolder</li>
<li>uploadFile</li>
<li>uploadFolder</li>
<li>isFile</li>
<li>listFiles</li>
<li>getHomeDirectory</li>
</ul>
</p>

<p>Having more time for improvements and optimizations, I also modified the GUI by using the multi-threaded philosophy from Java Swing. Until now all the GUI components were displayed by the initial thread which started the application. Also, the GUI components were updated by this thread or by helper threads that I started using the Callable interface. However, this is a wrong utilization of Java Swing because it can introduce subtle bugs. The correct utilization is to use an event dispatch thread, where all event-handling code is executed and Worker threads, also known as background threads, where time-consuming background tasks are executed. More details can be found <a href="https://docs.oracle.com/javase/tutorial/uiswing/concurrency/">here. </a><p>


<h3>
<a id="week-7" class="anchor" href="#week-7" aria-hidden="true"><span class="octicon octicon-link"></span></a>Week 7 and 8</h3>
<p><u>Deliverable 6:</u> Plugin with Progress Bar functionality</p>
<p>The messages area with text logging alerts was replaced with a modern table with progress bars. 

<center>
<figure>
<img src="images/progress_bar_table.png">
<figcaption>Table with progress bar</figcaption>
</figure>
</center>

This new table contains transfer statistics:
<ul>
<li>Source: in order to keep a smaller size for the table the source and destination path field might not cover all the text but they contain a tooltip which displays all text. </li>
<li>Destination</li>
<li>Current file: This is the name of the currently downloaded/uploaded file. While downloadind/uploading a folder this field is updated with the currently transferred file.</li>
<li>Progress: Progress bar with the current percentage of the transfer. For iRODS, the progress bar is updated in chunks of 4MB because of the Jargon API limitation. unfortunately, for Dropbox, the API doesn't provide a callback for getting the transfer status so the progress bar is updated only at the start of the transfer and at the end of the transfer. </li>
<li>Action: User can interrupt a transfer anytime. When the user clicks the "Cancel" button the Progress field is updated accordingly and the "Cancel" button becomes a "Details" button. </li>
</ul>
</p>

<p>
When the user clicks the "Details" button a new frame is opened. Statistics about the transfer are displayed, including a possible error during transfer. In the future week, I plan to add more transfer statistics like transfer size, size of every downloaded file from a folder and others.
<center>
<figure>
<img src="images/transfer_details.png">
<figcaption>Transfer Details</figcaption>
</figure>
</center>
</p>

<h3>
<a id="week-9" class="anchor" href="#week-9" aria-hidden="true"><span class="octicon octicon-link"></span></a>Week 9</h3>
<p><u>Deliverable 7:</u> Deliverable with the possibility to delete files</p>
<p> The functionality for deleting files was implemented only for iRODS. At this moment, Dropbox Java API doesn't expose methods for deleting files. User has access to this functionality using a right-click menu with the "Delete" option. 

<p>
When the user clicks the "Details" button a new frame is opened. After user confirmation, a Swing Worker
is started for accessing the cloud and deleting the file. Also, the Swing Worker removes the node from the cloud browsing tree by invoking a callback from the upper layers.
<center>
<figure>
<img src="images/popup_delete.png">
<figcaption>Delete Popup</figcaption>
</figure>
</center>

Every time a delete occurs, the table with progress bars is updated accordingly.
<center>
<figure>
<img src="images/delete_statistics.png">
<figcaption>Delete statistics</figcaption>
</figure>
</center>
</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/dorugucea91/CloudPlugin">CloudPlugin</a> is maintained by <a href="https://github.com/dorugucea91">dorugucea91</a>.</span>
        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>

